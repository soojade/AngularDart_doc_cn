## 多组件

我们的应用正在成长中。现在又有新的用例：重复使用组件，传递数据给组件并创建更多可复用的资源。让我们把英雄详情从英雄列表中分离出来，使英雄详情组件可以被复用。

运行这部分的[在线例子](http://angular-examples.github.io/toh-3)。

### 我们离开的地方

在继续《英雄之旅》之前，先检查一下，是否已经有了如下目录结构。如果没有，回上一章，看看错过了哪里。

```
angular_tour_of_heroes/
|---lib/
|    |---app_component.dart
|---web/
|    |---index.html
|    |---main.dart
|    |---styles.css
|---pubspec.yaml
```

#### 保持应用的编译和运行

我们需要启动Dart编译器，它会监视文件变化，并且启动服务器。我们只要敲入：

```
pub serve
```

这个命令会在我们构建《英雄之旅》的时候让应用保持运行。

### 制作英雄详情组件

我们的英雄列表和英雄详情目前位于同一个文件的同一个组件中。现在它们还很小，但很快它们都会变大。我们将来肯定会收到新需求：针对这一个，却不能影响另一个。然而，每一个更改都会给这两个组件带来风险和双倍的测试负担，却没有任何好处。 如果我们需要在应用的其它地方复用英雄详情组件，英雄列表组件也会跟着混进去。

我们当前的组件违反了*单一职责原则*。虽然这只是一个教程，但我们还是得坚持做正确的事——况且，做正确的事这么容易，在此过程中，我们又能学习如何构建 Angular 应用。

让我们把英雄详情拆分成一个独立的组件。

#### 拆分英雄详情组件

在`lib`目录下添加一个名为`hero_detail_component.dart`的文件，并且创建 `HeroDetailComponent`。代码如下：

```
import 'package:angular2/core.dart';

@Component(
    selector: 'my-hero-detail',
    )
class HeroDetailComponent {
}
```

> #### 命名约定
>
> 我们希望一眼就能看出哪些类是组件，哪些文件包含组件。
>
> 注意我们在`app_component.dart`的文件中有一个`AppComponent`组件。我们新的`HeroDetailComponent`组件在`hero_detail_component.dart`文件中。
>
> 我们的所有组件名都以"Component"结尾。所有组件的文件名都以"_component"结尾。

> 我们统一使用小写的**下划线命名法**(也叫*snake_case*)拼写文件名。这样在服务器或源代码控制系统中，就不必担心大小写问题了。

当我们创建组件的时候，一开始要导入 Angular 的`core.dart`文件，以便能使用`@Component`等通用类型。

我们使用`@Component`注解创建元数据，在其中指定选择器名称，用以标识此组件的元素。

做完这些，我们把它导入`AppComponent`组件，并创建相应的`<my-hero-detail>`元素。

#### 英雄详情模板

此时，`AppComponent`的*英雄列表*和*英雄详情*视图被组合进同一个模板中。让我们从`AppComponent`中**剪切**出英雄详情的内容，并且**粘贴**到`HeroDetailComponent`组件的`template`属性中。

我们之前绑定了`AppComponent`的`selectedHero.name`属性。`HeroDetailComponent`组件将会有一个`hero`属性，而不是`selectedHero`属性。所以，我们要把模板中的所有`selectedHero`替换为`hero`。只改这些就够了。最终结果如下所示：

```
template: '''
  <div *ngIf="hero != null">
    <h2>{ {hero.name} } details!</h2>
    <div><label>id: </label>{ {hero.id} }</div>
    <div>
      <label>name: </label>
      <input [(ngModel)]="hero.name" placeholder="name">
    </div>
  </div>'''
```

现在，我们的英雄详情布局只存在于`HeroDetailComponent`组件中。

#### 添加 hero 属性

把刚刚所说的`hero`属性添加到组件类。

```
Hero hero;
```

啊哦！我们声明`hero`属性是`Hero`类型，但是我们的`Hero`类还在`app_component.dart`文件中。我们有了两个组件，它们位于各自的文件，并且都需要引用`Hero`类。

要解决这个问题，我们得从`app_component.dart`文件中把`Hero`类移到属于它自己的`hero.dart`文件中。

```
class Hero {
  final int id;
  String name;

  Hero(this.id, this.name);
}
```

在`app_component.dart`和`hero_detail_component.dart`的顶部附近添加下列`import`语句：

```
import 'hero.dart';
```

#### hero 属性是一个输入属性

`HeroDetailComponent`必须被告知该显示哪个英雄。谁告诉它呢？自然是父组件`AppComponent`了！

`AppComponent`知道该显示哪个英雄——用户从列表中选中的那个。用户选择的英雄在它的`selectedHero`属性中。

我们马上更新`AppComponent`的模板，把该组件的`selectedHero`属性绑定到我们的`HeroDetailComponent`组件的`hero`属性上。绑定看起来可能是这样的：

```
<my-hero-detail [hero]="selectedHero"></my-hero-detail>
```

注意，`hero`是属性绑定的**目标**——它位于等号 (`=`) 左边方括号中。

Angular 要求我们把**目标**属性声明为组件的**输入**属性，否则，Angular 会拒绝绑定，并抛出错误。

> 我们在这里详细解释了输入属性，以及为什么目标属性需要这样的特殊待遇，而源属性却不需要。

我们有几种方式把`hero`声明成输入属性。这里我们采用首选的方式：通过使用`@Input`注解`hero`属性。

```
  @Input()
  Hero hero;
```

### 更新 AppComponent

我们回到`AppComponent`，让它使用`HeroDetailComponent`组件。

我们先导入`HeroDetailComponent`组件，以便可以引用它。

```
import 'hero_detail_component.dart';
```

在模板中，找到刚刚删除“英雄详情”内容的位置，添加表示`HeroDetailComponent`组件的元素标签：

```
<my-hero-detail></my-hero-detail>
```

> `my-hero-detail`是我们在`HeroDetailComponent`元数据中设置的`selector`

这两个组件目前还不能协同工作，直到我们把`AppComponent`组件的`selectedHero`属性绑定到`HeroDetailComponent`元素的`hero`属性上，就像这样：

```
<my-hero-detail [hero]="selectedHero"></my-hero-detail>
```

AppComponent的模板是这样的：

```
template: '''
  <h1>{ {title} }</h1>
  <h2>My Heroes</h2>
  <ul class="heroes">
    <li *ngFor="let hero of heroes"
      [class.selected]="hero == selectedHero"
      (click)="onSelect(hero)">
      <span class="badge">{ {hero.id} }</span> { {hero.name} }
    </li>
  </ul>
  <my-hero-detail [hero]="selectedHero"></my-hero-detail>
''',
```

多亏数据绑定机制，`HeroDetailComponent`可以从`AppComponent`接收到英雄数据，并在列表下方显示那个英雄的详情。每一次用户选择一个新英雄，详情都会更新。

现在什么都还没有发生！

我们点击列表内的英雄，并没有详细信息！我们在浏览器开发工具的控制台中找找看错误信息！但并没有出错。

似乎是Angular忽略了新的标签。确实如此！

#### 指令列表

浏览器会忽视它无法识别的标签和属性（attribute），Angular同样如此。

我们已经导入`HeroDetailComponent`，并在模板中使用它，但是我们并没有告诉Angular。

我们可以通过元数据的`directives`列表告诉 Angular 我们在模板中使用了哪些组件。让我们在`@Component`配置对象底部，紧跟着`template`和`styles`的后面，添加列表属性。

```
directives: const [HeroDetailComponent]
```

#### 搞定！

当在浏览器中查看应用时，可以看到英雄列表。当选中一个英雄时，可以看到所选英雄的详情。

从根本上的改变是，我们可以在应用中的任何地方使用这个`HeroDetailComponent`组件来显示英雄详情了。

我们创建了第一个可复用组件！

#### 回顾应用结构

来验证下吧，在本章中，经过这些漂亮的重构，我们应该得到下列结构：

```
angular_tour_of_heroes/
|---lib/
|    |---app_component.dart
|    |---hero.dart
|    |---hero_detail_component.dart
|---web/
|    |---index.html
|    |---main.dart
|    |---styles.css
|---pubspec.yaml
```

### 我们已经走过的路

来盘点一下我们已经构建了什么。

* 我们创建了一个可复用组件
* 我们学会了如何让一个组件接收输入
* 我们学会了把父组件绑定到子组件。
* 我们学会了需要在`directives`列表中声明应用指令

#### 前方的路

通过抽取共享组件，我们的《英雄之旅》变得更有复用性了。

但在`AppComponent`中，我们仍然使用着模拟数据。这不能忍。我们应该重构数据访问为一个独立的服务，并在需要数据的组件之间共享。

在下一章，我们将学习如何创建服务。

> 下一步
>
> [服务](./服务.md)