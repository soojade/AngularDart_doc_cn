## 服务

《英雄之旅》继续前行。接下来，我们准备添加更多的组件。

将来会有更多的组件访问英雄数据，我们不想一遍又一遍的复制粘贴同样的代码。我们将创建一个单一的、可复用的数据服务，然后学习如何把它注入到那些需要数据的组件中去。

我们将重构数据访问代码，把它隔离到一个独立的服务中去，让组件尽可能保持精简，专注于为视图提供支持。 在这种方式下，借助模拟服务来对组件进行单元测试也会更容易。

因为数据服务都是异步的，我们将在本章创建一个基于**Future**的数据服务。

运行这部分的[在线例子](http://angular-examples.github.io/toh-4)。

### 我们离开的地方

在继续《英雄之旅》之前，先来检查一下是否有以下目录结构。如果不是，你得回到上一章，并看看错过了什么。

```
angular_tour_of_heroes/
|---lib/
|    |---app_component.dart
|    |---hero.dart
|    |---hero_detail_component.dart
|---web/
|    |---index.html
|    |---main.dart
|    |---styles.css
|---pubspec.yaml
```

#### 保持应用的编译和运行

我们需要启动Dart编译器，它会监视文件变化，并且启动服务器。我们只要敲入：

```
pub serve
```

在我们继续构建《英雄之旅》的时候，这个命令会让应用运行并自动更新。

### 创建英雄服务

客户向我们描绘了本应用更大的目标：想要在不同的页面中用多种方式显示英雄。现在我们已经能从列表中选择一个英雄了。很快，我们将添加一个仪表盘来显示表现最好的英雄，并创建一个独立视图来编辑英雄的详情。所有这些视图都需要英雄数据。

目前，`AppComponent`显示的是模拟数据。至少有两个地方可以改进。首先，定义英雄的数据不该是组件的任务。其次，我们把这份英雄列表的数据共享给其它组件和视图并不容易。

我们可以把获取英雄数据的任务重构为一个单独的服务，它将提供英雄数据，并把服务在所有需要英雄数据的组件间共享。

#### 创建 HeroService

在`lib`目录下创建一个名为`hero_service.dart`的文件。

> 我们遵循的文件命名约定是：服务名称的小写形式（基本名），加上`_service`后缀。如果服务名称包含多个单词，我们就把基本名部分写成下划线形式 (也叫*snake_case*)。`SpecialSuperHeroService`服务应该被定义在`special_super_hero_service.dart`文件中。

我们把这个类命名为`HeroService`。

```
import 'package:angular2/core.dart';

import 'hero.dart';
import 'mock_heroes.dart';

@Injectable()
class HeroService {
}
```

#### 可注入的服务

注意，我们使用了`@Injectable()`注解。

> **不要忘了写圆括号！**如果忘了写，就会导致一个很难诊断的错误。

Dart 看到`@Injectable()`注解时，就会记下本服务的元数据。如果 Angular 需要往这个服务中注入其它依赖，就会使用这些元数据。

此时，`HeroService`还没有任何依赖，但无论如何还得添加注解。作为一项最佳实践，无论是出于提高统一性还是减少变更的目的，都应该从一开始就加上`@Injectable()`注解。

#### 获取英雄数据

添加一个`getHeroes`空方法。

```
@Injectable()
class HeroService {
  List<Hero> getHeroes() {} // stub
}
```

在这个实现上暂停一下，我们先来讲一个重点。

我们服务的消费者并不知道本服务会如何获取数据。我们的`HeroService`服务可以从任何地方获取`Hero`的数据。它可以从网络服务器获取，可以从浏览器的局部存储区获取，也可以从模拟的数据源。

这就是从组件中移除数据访问代码的美妙之处。这样我们可以随时改变数据访问的实现方式，而无需对使用英雄的组件作任何改动。

#### 模拟英雄数据

我们已经在`AppComponent`组件中有了模拟`Hero`数据。它不该在那里，但也不该在这里！我们应把模拟数据移到它自己的文件中去。

从`app_component.dart`文件中剪切`mockHeroes`列表，并把它粘贴到`lib`目录下新建的`mock_heroes.dart`的文件中。我们复制`import 'hero.dart'`语句，因为我们的英雄列表用到了`Hero`类。

```
import 'hero.dart';

final List<Hero> mockHeroes = [
	new Hero(11, 'Mr. Nice'),
	new Hero(12, 'Narco'),
	new Hero(13, 'Bombasto'),
	new Hero(14, 'Celeritas'),
	new Hero(15, 'Magneta'),
	new Hero(16, 'RubberMan'),
	new Hero(17, 'Dynama'),
	new Hero(18, 'Dr IQ'),
	new Hero(19, 'Magma'),
	new Hero(20, 'Tornado')
];
```

同时，回到刚剪切出`mockHeroes`列表的`app_component.dart`文件中，我们留下一个尚未初始化的`heroes`属性：

```
List<Hero> heroes;
```

#### 返回模拟的英雄数据

回到`HeroService`，我们导入模拟的`mockHeroes`，并从`getHeroes` 方法中返回它。我们的`HeroService`服务现在看起来是这样的：

```
import 'package:angular2/core.dart';

import 'hero.dart';
import 'mock_heroes.dart';

@Injectable()
class HeroService {
  List<Hero> getHeroes() => mockHeroes;
}
```

#### 使用英雄服务

我们已经准备好在多个组件中使用`HeroService`服务了，先从`AppComponent`开始

通常，我们先导入要用的东西，例如`HeroService`。

```
import 'hero_service.dart';
```

导入这个服务让我们可以在代码中引用它。`AppComponent`该如何在运行中获得一个具体的`HeroService`实例呢？

#### 我们要自己 new 出这个 HeroService 吗？不！

尽管我们可以使用`new`来创建`HeroService`的实例，就像这样：

```
HeroService heroService = new HeroService(); // don't do this
```

这不是个好主意，有很多理由，例如：

* 我们的组件得弄清楚该如何创建`HeroService`。如果有一天我们修改了`HeroService`的构造函数，我们不得不找出创建过此服务的每一处代码，并修改它。围着补丁代码转圈很容易导致错误，还会增加测试负担。
* 我们每次使用`new`都会创建一个新的服务实例。如果这个服务需要缓存英雄列表，并把这个缓存共享给别人呢？怎么办？没办法，做不到。
* 我们把`AppComponent`锁定到`HeroService`的一个特定实现。我们很难在不同的场景中切换实现。例如，能离线操作吗？能在测试时使用不同的模拟版本吗？这可不容易。

如果……如果……嘿！这下我们可有得忙了！

有办法了，真的！这个办法真是简单得不可思议，它能解决这些问题，你就再也没有犯错误的借口了。

#### 注入 HeroService

用下面三行代码代替用`new`时的一行：

1. 添加一个属性
2. 添加一个构造函数并设置属性
3. 添加组件的`providers`元数据

下面就是属性和构造函数：

```
final HeroService _heroService;
AppComponent(this._heroService);
```

构造函数除了设置类型为`_heroService`属性什么也不做。`HeroService`类型的`_heroService`属性会将构造函数的参数标识为`HeroService`的注入点。

现在，当创建`AppComponent`实例时，Angular 知道需要先提供一个`HeroService`的实例。

Angular 必须从某些地方获取实例。这就是就是 Angular 依赖注入扮演的角色。**注入器**有一个包含着之前创建服务的**容器**。要么从容器中找到并返回一个之前存在的`HeroService`实例，要么创建一个新实例，把它添加到容器，返回给 Angular。

注入器（injector）还不知道怎样创建`HeroService`。如果我们现在运行代码，Angular会失败，并报错：

```
EXCEPTION: No provider for HeroService! (AppComponent -> HeroService)
```

我们必须通过注册一个`HeroService`**提供者**来告诉*注入器*怎样创建`HeroService`实例。要做到这一点，通过在组件元数据`@Component`注解底部添加如下的`providers`参数：

```
providers: const [HeroService])
```

`providers`参数告诉 Angular，当它创建新的`AppComponent`组件时，也要创建一个`HeroService`的新实例。`AppComponent`会使用那个服务来获取英雄列表，在它组件树中的每一个子组件也同样如此。

> #### 服务和组件树
>
> 回想一下，`AppComponent`创建一个`HeroDetail`实力，由于`<my-hero-detail>`标签在它的模板底部。`HeroDetail`就是`AppComponent`的子组件。
>
> 如果`HeroDetailComponent`需要父组件的`HeroService`，它会请求 Angular 将服务注入到它的构造函数中，看起来就像一个`AppComponent`：
>
> ```
> final HeroService _heroService;
> HeroDetailComponent (this._heroService);
> ```
>
> `HeroDetailComponent`决不能重复设置父组件的`providers`列表!
>
> `AppComponent`是我们应用的顶层组件。应该仅有一个该组件的实例。并且，在我们的整个应用中，也应该仅有一个`HeroService`的实例。

#### AppComponent 中的 getHeroes

我们已经获得了此服务，并把它存入了私有变量`_heroService`中。让我们开始使用它。

停下来想一想。我们可以在同一行内调用此服务并获得数据。

```
heroes = _heroService.getHeroes();
```

实际上，我们并不需要把一行代码包装成一个专门的方法，但无论如何，我们在演示代码中先这么写：

```
  void getHeroes() {
    heroes = _heroService.getHeroes();
  }
```

#### ngOnInit 生命周期钩子

毫无疑问，`AppComponent`应该获取和现实英雄数据。我们该在哪里调用`getHeroes`方法呢？在构造函数中吗？*不*！

多年的经验和惨痛的教训教育我们，应该把复杂的逻辑扔到构造函数外面去，特别是那些需要从服务器获取数据的逻辑更是如此。

构造函数是为了简单的初始化工作而设计的，例如把构造函数的参数赋值给属性。它的负担不应该过于沉重。我们应该能在测试中创建一个组件，而不用担心它会做实际的工作——例如和服务器通讯，直到我们主动要求它做这些。

如果不在构造函数中，总得有地方调用`getHeroes`吧。

如果我们实现了 Angular 的 **ngOnInit** 生命周期钩子，Angular 就会主动调用这个钩子。Angular提供了一些接口，用来介入组件生命周期的几个关键时间点：刚创建时、每次变化时，以及最终被销毁时。

每个接口都有唯一的一个方法。只要组件实现了这个方法，Angular 就会在适当的时机调用它。

这是使用`OnInit`接口的基本结构：

```
import 'package:angular2/core.dart';

class AppComponent implements OnInit {
  void ngOnInit() {
  }
}
```

我们写了一个带有初始化逻辑的`ngOnInit`方法，Angular会在适当的时候调用它。在这个例子中，我们通过调用`getHeroes`来完成初始化。

```
  void ngOnInit() {
    getHeroes();
  }
```

我们的应用将会像期望的那样运行，显示英雄列表，并且在我们点击英雄的名字时，显示英雄的详情。

我们就快完成了，但还有点事情不太对劲。

### 异步服务与 Future

我们的`HeroService`直接返回一个模拟英雄的列表，它的`getHeroes`函数签名是同步类型的：

```
heroes = _heroService.getHeroes();
```

请求英雄数据，返回结果中就有它们了。

将来，我们打算从远端服务器上获取英雄数据。我们还没调用 http，但在后面的章节中我们会希望这么做。

那时候，我们不得不等待服务器响应，并且在等待过程中我们无法阻塞用户界面响应，即使我们想这么做（也不应这么做）也做不到，因为浏览器不会阻塞。

我们不得不使用一些异步技术，而这将改变`getHeroes`方法的签名。

我们将使用 *Future* 。

#### 让 HeroService 返回 Future

我们请求一个异步服务来执行一些工作任务，并在 Future 中返回给我们结果。该服务会执行任务（某个地方），最后使用任务的结果或错误信息更新 Future。

使用返回 Future的 `getHeroes`方法，更新 `HeroService`：

```
Future<List<Hero>> getHeroes() async => mockHeroes;
```

我们继续使用模拟数据。我们通过返回一个使用模拟英雄立即解决的 Future 作为结果，模拟了一个超快、零延迟的服务器。

> 将方法体标记为`async`，使方法立即返回一个`Future`对象。随后 Future 会通过方法的返回值完成。

#### 基于 Future 的行动

回到`AppComponent`和它的`getHeroes`方法，我们看到它看起来还是这样的：

```
  void getHeroes() {
    heroes = _heroService.getHeroes();
  }
```

在修改了`HeroService`之后，我们还要把`heroes`设置为一个 Future，而不再是一个英雄列表。

我们得修改这个实现，把它变成基于 Future 的，并在事情被解决时再行动。我们可以等待 Future 解决，之后就会显示英雄数据:

```
Future<Null> getHeroes() async {
  heroes = await _heroService.getHeroes();
}
```

我们的代码会一直等待，直到 Future 完成，然后将组件的 `heroes` 属性设置为服务返回的英雄列表。是的，这就搞定了！

我们的程序仍在运行，仍在显示英雄列表，在选择英雄时，仍然会把它显示在详情页面中。

#### 回顾应用结构

再检查下，经历了本章的所有重构之后，应该有了下列文件结构：

```
angular_tour_of_heroes/
|___lib/
|   |___app_component.dart
|   |___hero.dart
|   |___hero_detail_component.dart
|   |___hero_service.dart
|   |___mock_heroes.dart
|___web/
|   |___index.html
|   |___main.dart
|   |___styles.css
|___pubspec.yaml
```

### 我们已经走过的路

我们来盘点一下已经构建的内容：

* 我们创建了一个能被多个组件共享的服务类
* 我们使用`ngOnInit`生命周期钩子，以便在`AppComponent`激活时获取英雄数据
* 我们把 `HeroService` 定义为 `AppComponent` 的一个提供者（provider）
* 我们创建了一个模拟的英雄数据，并把它们导入到我们的服务中
* 我们把服务设计为返回Future，然后组件从Future中获取数据

#### 前方的路

通过使用共享组件和服务，我们的《英雄之旅》更有复用性了。我们还要创建一个仪表盘，要添加在视图间路由的菜单链接，还要在模板中格式化数据。随着我们应用的进化，我们还会学到如何进行设计，让它更易于扩展和维护。

我们将在下一章学习 Angular 组件路由，以及在视图间导航的知识。

#### 附件：慢一点

我们可以模拟慢速连接。

在 `HeroService` 中添加如下的 `getHeroesSlowly` 方法：

```
Future<List<Hero>> getHeroesSlowly() {
  return new Future.delayed(const Duration(seconds: 2), getHeroes);
}
```

像 `getHeroes` 一样，它也返回一个 Future 。但是，这个 Future 会在提供模拟数据之前等待两秒钟。

回到 `AppComponent` ，用 `_heroService.getHeroesSlowly` 替换掉 `_heroService.getHeroes` ，并观察本应用的行为表现。

#### 附录：覆盖父组件的服务

我们前面（服务和组件树 章节）说过，将父组件 `AppComponent` 中的 `HeroService` 服务注入到 `HeroDetailComponent` 时，决不能在 `HeroDetailComponent` 的元数据中添加 `providers` 列表。

为什么？因为它会告诉 Angular ，在 `HeroDetailComponent` 层的时候创建一个新的 `HeroService` 实例。而 `HeroDetailComponent` 并不需要它自己的服务实例，它需要的是父组件的服务实例。添加 `providers` 列表会创建一个新的服务实例，并覆盖父组件的实例。

仔细想一下，我们应该在哪里、什么时候注册提供提供者rovider），理解注册的作用域。小心不要在错误的层上创建一个新的实例。

> 下一步
>
> [路由](./路由.md)